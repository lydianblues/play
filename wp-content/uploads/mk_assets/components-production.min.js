(function( $ ) {
    'use strict';

    // If we want to get access to API of already initilised component we run a regular new conctructor.
    // When instance is discovered in cache object then we return exisiting instance.
    // 
    // TODO move it to core functions and run logic on init
    var _instancesCollecetion = {};

    MK.component.SwipeSlideshow = function( el ) {
        var $this = $( el );
        var id = $this.parent().attr('id');

        this.el = el;
        this.id = id;
        this.config = $this.data( 'swipeslideshow-config' );
        if( this.config ) this.config.hasPagination = false;
    };

    MK.component.SwipeSlideshow.prototype = {
        init : function() {
            var slider = new MK.ui.Slider( this.el, this.config );
            slider.init();

            _instancesCollecetion[ this.id ] = slider;
        }
    };


    // Additional nav
    // Mostly for thumbs in woocommerce

    MK.component.SwipeSlideshowExtraNav = function( el ) {
        this.el = el;
    };

    MK.component.SwipeSlideshowExtraNav.prototype = {
        init : function init() {
            this.cacheElements();
            this.bindEvents();
        },

        cacheElements : function cacheElements() {
            var $this = $( this.el );

            this.sliderId = $this.data( 'gallery' );
            this.slider = _instancesCollecetion[this.sliderId]; // convert to js obj
            this.$thumbs = $( '#' + this.sliderId ).find( '.thumbnails a');
        },

        bindEvents : function bindEvents() {
            this.$thumbs.on( 'click', this.clickThumb.bind( this ) );
        },

        clickThumb : function clickThumb( e ) {
            e.preventDefault();
            var $this = $( e.currentTarget ),
                id = $this.index();

            this.slider.goTo( id );
        }
    };


    // Mostly for switcher in woocommerce
    // 
    MK.utils.eventManager.subscribe('gallery-update', function(e, config) {
        if(typeof _instancesCollecetion[config.id] === 'undefined') return;
        _instancesCollecetion[config.id].reset();
    });

})( jQuery ); 
 (function ($) {
	'use strict';  

	function dynamicHeight() {
		var $this = $( this );

		$this.height( 'auto' );

		if( window.matchMedia( '(max-width: 768px)' ).matches ) {
			return;
		} 
		 
		$this.height( $this.height() );
	}


	var $window = $( window );
	var container = document.getElementById( 'mk-theme-container' );

	$( '.equal-columns' ).each( function() { 
		dynamicHeight.bind( this );
	    $window.on( 'load', dynamicHeight.bind( this ) );
	    $window.on( 'resize', dynamicHeight.bind( this ) );
	    window.addResizeListener( container, dynamicHeight.bind( this ) );
	});

}( jQuery )); 
 (function($) {
	'use strict';

	MK.component.EdgeSlider = function( el ) {
		var self = this,
			$this = $( el ), 
            $window = $(window),
            $wrapper = $this.parent(),
			config = $this.data( 'edgeslider-config' );

        var callbacks = { 

    		onInitialize : function( slides ) {
    			self.$slides = $( slides );
				
				self.slideContents = $.map( self.$slides, function( slide ) {
					var $slide = $( slide ),
						title = $slide.find('.edge-slide-content .edge-title').first().text(),
						skin = $slide.attr("data-header-skin"),
						image = $slide.find('.mk-section-image').css('background-image') || 
								$slide.find('.mk-video-section-touch').css('background-image'),
						bgColor = $slide.find('.mk-section-image').css('background-color');

					return {
						skin: skin,
						title: title,
						image: image,
						bgColor: bgColor
					};
				});

				setNavigationContent( 1, self.$slides.length - 1 );
				setSkin( 0 );

                setTimeout( function() {
                    $( '.edge-slider-loading' ).fadeOut( '100' );
                }, 1000 );
    		},

    		onAfterSlide : function( id ) {
    			var currentId = id;

				var len = self.$slides.length,
					nextId = ( currentId + 1 === len ) ? 0 : currentId + 1,
					prevId = ( currentId - 1 === -1 ) ? len - 1 : currentId - 1; 

    			setNavigationContent( nextId, prevId );
    			setSkin( id );
    		}
    	};


    	var $nav = $( config.nav ),
    		$prev = $nav.find( '.mk-edge-prev' ),
    		$prevTitle = $prev.find( '.nav-item-caption' ),
    		$prevBg = $prev.find('.edge-nav-bg'),
    		$next = $nav.find( '.mk-edge-next' ),
    		$nextTitle = $next.find( '.nav-item-caption' ),
    		$nextBg = $next.find('.edge-nav-bg');

        var setNavigationContent = function( nextId, prevId ) {

            if(self.slideContents[ prevId ]) {
        		$prevTitle.text( self.slideContents[ prevId ].title );
        		$prevBg.css( 'background', 
        			self.slideContents[ prevId ].image !== 'none' ? 
        				self.slideContents[ prevId ].image :
        				self.slideContents[ prevId ].bgColor );
            }

            if(self.slideContents[ nextId ]) {
        		$nextTitle.text( self.slideContents[ nextId ].title ); 
        		$nextBg.css( 'background', 
        			self.slideContents[ nextId ].image !== 'none' ? 
        				self.slideContents[ nextId ].image :
        				self.slideContents[ nextId ].bgColor );
            }
        };


        var $navBtns = $nav.find( 'a' ),  
        	$pagination = $( '.swiper-pagination' ),
        	$skipBtn = $( '.edge-skip-slider' ),
            currentSkin = null;

        var setSkin = function( id ) {  
        	currentSkin = self.slideContents[ id ].skin;

          	$navBtns.attr('data-skin', currentSkin);
          	$pagination.attr('data-skin', currentSkin);
         	$skipBtn.attr('data-skin', currentSkin); 

         	if( self.config.firstEl ) {
         		MK.utils.eventManager.publish( 'firstElSkinChange', currentSkin );
         	}
        };


        var currentPoint;
        var $opacityLayer = $this.find('.edge-slide-content');
        var winH = null;
        var opacity = null;
        var offset = null;

        var onResize = function onResize() {
            var height = $wrapper.height();
            $this.height( height );

            var width = $wrapper.width();
            $this.width( width );

            winH = $window.height();
            offset = $this.offset().top;

            if(MK.utils.isResponsiveMenuState()) {
                $this.css({
                    '-webkit-transform': 0,
                    '-moz-transform': 0,
                    '-ms-transform': 0,
                    '-o-transform': 0,
                    'transform': 0,
                    'position': 'absolute'
                });
                $opacityLayer.css({
                    'opacity': 1
                });
            } else {
                onScroll();
            }
        };

        var onScroll = function onScroll() {
            currentPoint = - MK.val.scroll();

            if( offset + currentPoint <= 0 ) {
                opacity = 1 + ((offset + currentPoint) / winH) * 2;
                opacity = Math.min(opacity, 1);
                opacity = Math.max(opacity, 0);

                $opacityLayer.css({
                    opacity: opacity
                });
            }

            $this.css({
                '-webkit-transform': 'translateY(' + currentPoint + 'px) translateZ(0)',
                '-moz-transform': 'translateY(' + currentPoint + 'px) translateZ(0)',
                '-ms-transform': 'translateY(' + currentPoint + 'px) translateZ(0)',
                '-o-transform': 'translateY(' + currentPoint + 'px) translateZ(0)',
                'transform': 'translateY(' + currentPoint + 'px) translateZ(0)',
                'position': 'fixed'
            });  
        };

        onResize();
        $window.on('load resize', onResize);
        window.addResizeListener( $wrapper.get(0), onResize );

        onScroll();
        $window.on('scroll', function() {
            if(MK.utils.isResponsiveMenuState()) return;
            window.requestAnimationFrame(onScroll);
        });

		this.el = el;
		this.config = $.extend( config, callbacks );
		this.slideContents = null; // cache slide contents
	};

	MK.component.EdgeSlider.prototype = {
		init : function() {
			// Inherit from Slider. add prototypes if needed
			var slider = new MK.ui.Slider( this.el, this.config );
			slider.init();
		}
	};

})(jQuery); 
 // (function($) {
// 	'use strict';

// 	$('.js-blend-mode').each( blend );

// 	function blend() {
// 		var layer = this,
// 			style = layer.currentStyle || window.getComputedStyle(layer, false),
// 			img = style.backgroundImage,
// 			color = style.backgroundColor,
// 			mode = layer.getAttribute('data-blend'),
// 			canvas = layer.getElementsByTagName('canvas')[0],
// 			output = layer.querySelectorAll('.mk-blend-layer')[0],
// 			isLuminosity = (mode === 'luminosity');

// 		img = img.replace('url(', '').replace(')', '').replace(/"/g, '').replace(/'/g, ''); 
// 		color = color.replace('(', '').replace(')', '').replace('rgba', '').replace('rgb', '').split(',');
// 		mode = (mode === 'soft-light') ? 'softLight' : mode;
// 		mode = (mode === 'luminosity') ? 'overlay' : mode;


// 	    MK.core.loadDependencies([ MK.core.path.plugins + 'caman.js' ], function() {
 
// 	    	Caman(canvas, img, function () { 
// 	    		if(isLuminosity) this.greyscale();

// 	    		this.newLayer(function () {
// 			  		this.fillColor( rgb2hex( color ) );
//     				this.opacity( rgba2opacity( color ) * 100 );
// 			  		this.setBlendingMode( mode );
// 			  	});

// 				this.render(function() {
// 					var img = this.toBase64();
// 					output.style.backgroundImage = 'url(' + img + ')';
// 				});
// 			});

// 	    });
// 	}

// 	function rgb2hex(rgb) { // or rgba is also fine
// 	    function hex(x) {
// 	        return ("0" + parseInt(x).toString(16)).slice(-2);
// 	    }
// 	    return "#" + hex(rgb[0]) + hex(rgb[1]) + hex(rgb[2]);
// 	}

// 	function rgba2opacity(rgba) {
// 		var a = rgba[3].replace(' ', '');
// 		return Number(rgba[3]) || 1;
// 	}

// }(jQuery));


(function($) {
	'use strict';

	/* Page Section Intro Effects */
	/* -------------------------------------------------------------------- */

	function mk_section_intro_effects() {
	  if ( !MK.utils.isMobile() ) {
	    if($.exists('.mk-page-section.intro-true')) {

	      $('.mk-page-section.intro-true').each(function() {
	        var that = this;
	        MK.core.loadDependencies([ MK.core.path.plugins + 'jquery.sectiontrans.js', MK.core.path.plugins + 'tweenmax.js' ], function() {
	          var $this = $(that),
	              $pageCnt = $this.nextAll('div'),
	              windowHeight = $(window).height(),
	              effectName = $this.attr('data-intro-effect'),
	              $header = $('.mk-header');

	              var effect = {
	                    fade :    new TimelineLite({paused: true})
	                              .set($pageCnt, { opacity: 0, y: windowHeight * 0.3 })
	                              .to($this, 1, { opacity: 0, ease:Power2.easeInOut })
	                              .to($pageCnt, 1, { opacity: 1, y: 0, ease:Power2.easeInOut}, "-=.7")
	                              .set($this, { zIndex: '-1'}),

	                    zoom_out : new TimelineLite({paused: true})
	                              .set($pageCnt, { opacity: 0, y: windowHeight * 0.3})
	                              .to($this, 1.5, { opacity: .8, scale: 0.8, y: -windowHeight - 100, ease:Strong.easeInOut })
	                              .to($pageCnt, 1.5, { opacity: 1, y:  0, ease:Strong.easeInOut}, "-=1.3"),

	                    shuffle : new TimelineLite({paused: true})
	                              .to($this, 1.5, { y: -windowHeight/2, ease:Strong.easeInOut })
	                              .to($this.nextAll('div').first(), 1.5, { paddingTop: windowHeight/2, ease:Strong.easeInOut }, "-=1.3")
	              }
	      

	          $this.sectiontrans({
	            effect : effectName,
	          });

	          if($this.hasClass('shuffled')) {
	            TweenLite.set($this, { y: -windowHeight/2 });
	            TweenLite.set($this.nextAll('div').first(), { paddingTop: windowHeight/2 });
	          }

	          $('body').on('page_intro', function() {
	            MK.utils.scroll.disable();
	            $(this).data('intro', true);
	            effect[effectName].play();
	            setTimeout(function() {
	              $header.addClass('pre-sticky');
	              $header.addClass('a-sticky');
	              $('.mk-header-padding-wrapper').addClass('enable-padding');
	              $('body').data('intro', false);
	              if(effectName === 'shuffle') $this.addClass('shuffled');
	            }, 1000);

	            setTimeout(MK.utils.scroll.enable, 1500);
	          });

	          $('body').on('page_outro', function() {
	            MK.utils.scroll.disable();
	            $(this).data('intro', true);
	            effect[effectName].reverse();
	            setTimeout(function() {
	              $header.removeClass('pre-sticky');
	              $header.removeClass('a-sticky');
	              $('.mk-header-padding-wrapper').removeClass('enable-padding');
	              $('body').data('intro', false);
	              if($this.hasClass('shuffled')) $this.removeClass('shuffled');
	            }, 1000);
	            
	            setTimeout(MK.utils.scroll.enable, 1500);
	          });
	        });
	      });
	    }
	  } else {
	    $('.mk-page-section.intro-true').each(function() {
	      $(this).attr('data-intro-effect', '');
	    });
	  }
	}

	mk_section_intro_effects();

    var debounceResize = null;
    $(window).on("resize", function() {
        if( debounceResize !== null ) { clearTimeout( debounceResize ); }
        debounceResize = setTimeout( mk_section_intro_effects, 300 );
    });



}(jQuery)); 
 (function($) {
    'use strict';

    var zIndex = 0;

    $(document).on('click', '.blog-loop-comments', function (event) {
        event.preventDefault();

        var $this = $(event.currentTarget);
        var $parent = $this.parents('.mk-blog-newspaper-item');

        $parent.css('z-index', ++zIndex);
        $this.parents('.newspaper-item-footer').find('.newspaper-social-share').slideUp(200).end().find('.newspaper-comments-list').slideDown(200);
        setTimeout( function() {
          MK.utils.eventManager.publish('item-expanded');
        }, 300);
    });

    $(document).on('click', '.newspaper-item-share', function (event) {
        event.preventDefault();

        var $this = $(event.currentTarget);
        var $parent = $this.parents('.mk-blog-newspaper-item');

        $parent.css('z-index', ++zIndex);
        $this.parents('.newspaper-item-footer').find('.newspaper-comments-list').slideUp(200).end().find('.newspaper-social-share').slideDown(200);
        setTimeout( function() {
          MK.utils.eventManager.publish('item-expanded');
        }, 300);
    });

}(jQuery)); 
 (function($) {
	'use strict';

	function mk_page_title_parallax() {
	    if (!MK.utils.isMobile() && mk_smooth_scroll !== 'false') {

	        $('.mk-effect-wrapper').each(function() {
	            var $this = $(this),
                	progressVal,
                    currentPoint,
                    ticking = false,
                    scrollY = MK.val.scroll(),
                    $window = $(window),
                    windowHeight = $(window).height(),
                    parentHeight = $this.outerHeight(),
                    startPoint = 0,
                    endPoint = $this.offset().top + parentHeight,
                    effectLayer = $this.find('.mk-effect-bg-layer'),
                    gradientLayer = effectLayer.find('.mk-effect-gradient-layer'),
                    cntLayer = $this.find('.mk-page-title-box-content'),
                    animation = effectLayer.attr('data-effect'),
                    top = $this.offset().top,
                    height = $this.outerHeight();

                var parallaxSpeed = 0.7,
                    zoomFactor = 1.3;

                var parallaxTopGap = function() {
                    var gap = top * parallaxSpeed;

                    effectLayer.css({
                        height : height + gap + 'px',
                        top : (-gap) + 'px'
                    });
                };


                if (animation == ("parallax" || "parallaxZoomOut") ) {
                    parallaxTopGap();
                }

                var animationSet = function() {
                    scrollY = MK.val.scroll();

                    if (animation == "parallax") {
                        currentPoint = (startPoint + scrollY) * parallaxSpeed;
                        effectLayer.get(0).style.transform = 'translateY(' + currentPoint + 'px)';
                    }

                    if (animation == "parallaxZoomOut") {
                    	console.log(effectLayer);
                        currentPoint = (startPoint + scrollY) * parallaxSpeed;
                        progressVal = (1 / (endPoint - startPoint) * (scrollY - startPoint));
                        var zoomCalc = zoomFactor - ((zoomFactor - 1) * progressVal);

                        effectLayer.get(0).style.transform = 'translateY(' + currentPoint + 'px) scale(' + zoomCalc + ')';
                    }

                    if (animation == "gradient") {
                        progressVal = (1 / (endPoint - startPoint) * (scrollY - startPoint));
                        gradientLayer.css({
                            opacity: progressVal * 2
                        });
                    }

                    if (animation != "gradient") {
                        progressVal = (1 / (endPoint - startPoint) * (scrollY - startPoint));
                        cntLayer.css({
                            opacity: 1 - (progressVal * 4)
                        });
                    }

                    // Stop ticking
                    ticking = false;
                };
                animationSet();

                // This will limit the calculation of the background position to
                // 60fps as well as blocking it from running multiple times at once
                var requestTick = function() {
                    if (!ticking) {
                        window.requestAnimationFrame(animationSet);
                        ticking = true;
                    }
                };

                $window.off('scroll', requestTick);
                $window.on('scroll', requestTick);

	        });
	    }
	}


	var $window = $(window);
	var debounceResize = null;

	$window.on('load', mk_page_title_parallax);
    $window.on("resize", function() {
        if( debounceResize !== null ) { clearTimeout( debounceResize ); }
        debounceResize = setTimeout( mk_page_title_parallax, 300 );
    });

}(jQuery)); 
 (function($) {
    'use strict';

    var core = MK.core,
        path = core.path;

    MK.component.Chart = function(el) {
        var init = function() {
            MK.core.loadDependencies([MK.core.path.plugins + 'jquery.easyPieChart.js'], function() {
                $('.mk-chart__chart').each(function() {
                    var $this = $(this),
                        $parent_width = $(this).parent().width(),
                        $chart_size = parseInt($this.attr('data-barSize'));

                    if ($parent_width < $chart_size) {
                        $chart_size = $parent_width;
                        $this.css('line-height', $chart_size);
                        $this.find('i').css({
                            'line-height': $chart_size + 'px'
                        });
                        $this.css({
                            'line-height': $chart_size + 'px'
                        });
                    }

                    var build = function() {
                        $this.easyPieChart({
                            animate: 1300,
                            lineCap: 'butt',
                            lineWidth: $this.attr('data-lineWidth'),
                            size: $chart_size,
                            barColor: $this.attr('data-barColor'),
                            trackColor: $this.attr('data-trackColor'),
                            scaleColor: 'transparent',
                            onStep: function(value) {
                                this.$el.find('.chart-percent span').text(Math.ceil(value));
                            }
                        });
                    };

                    // refactored only :in-viewport logic. rest is to-do
                    MK.utils.scrollSpy(this, {
                        position: 'bottom',
                        after: build
                    });
                });
            });
        };

        return {
            init: init
        };
    };

})(jQuery);
 
 (function($) {
    'use strict';

    var _toBuild = [];

    MK.component.AdvancedGMaps = function(el) {
        var $this = $(el),
            container = document.getElementById( 'mk-theme-container' ),
            data = $this.data( 'advancedgmaps-config' ),
            map = null,
            bounds = null,
            infoWindow = null,
            position = null;

        var build = function() {
            data.options.scrollwheel = false;
            data.options.mapTypeId = google.maps.MapTypeId[data.options.mapTypeId];
            data.options.styles = data.style;


            bounds = new google.maps.LatLngBounds();
            map = new google.maps.Map(el, data.options);
            infoWindow = new google.maps.InfoWindow();
            

             map.setOptions({
                panControl : data.options.panControl,
                draggable:  data.options.draggable,
                zoomControl:  data.options.zoomControl,
                mapTypeControl:  data.options.scaleControl,
                scaleControl:  data.options.mapTypeControl,
            });

            var marker, i;

            map.setTilt(45);

            for (i = 0; i < data.places.length; i++) {
                position = new google.maps.LatLng(data.places[i].latitude, data.places[i].longitude);

                bounds.extend(position);

                marker = new google.maps.Marker({
                    position: position,
                    map: map,
                    title: data.places[i].address,
                    icon: data.icon
                });


                google.maps.event.addListener(marker, 'click', (function(marker, i) {
                    return function() { 
                        if(data.places[i].address.length > 1) {
                            infoWindow.setContent('<div class="info_content"><p>'+ data.places[i].address +'</p></div>');
                        }
                        infoWindow.open(map, marker);
                    };
                })(marker, i));

                map.fitBounds(bounds);
            }

            var boundsListener = google.maps.event.addListener((map), 'bounds_changed', function(event) {
                this.setZoom(data.options.zoom);
                google.maps.event.removeListener(boundsListener);
            });


            var update = function() {
                google.maps.event.trigger(map, "resize");
                map.setCenter(position);
            };
            update();


            var bindEvents = function() {
                $( window ).on( 'resize', update );
                window.addResizeListener( container, update );
            };
            bindEvents();
        };


        var initAll = function() {
            for( var i = 0, l = _toBuild.length; i < l; i++ ) {
                _toBuild[i]();
            }
        };

        MK.api.advancedgmaps = MK.api.advancedgmaps || function() {
            initAll();
        };

        return {
            init : function() {
                _toBuild.push( build );
                MK.core.loadDependencies(['https://maps.googleapis.com/maps/api/js?callback=MK.api.advancedgmaps']);
            }
        };

    };
})(jQuery); 
 